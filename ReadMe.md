# 1. Формулу вычисления количества unit-тестов на основании значений, генерируемых JaCoCo

Количество тестовых случаев, необходимых для достижения тщательного тестового покрытия конкретного модуля можно рассчитать, используя **цикломатическую сложность кода**. Цикломатическая сложность была разработана Томасом Дж. МакКейбом в 1976 году. 

Если исходный код не содержит никаких точек ветвления или циклов, то сложность равна единице, поскольку есть только единственный маршрут через код. Если код имеет единственный оператор if, содержащий простое условие, то существует два пути через код: один если условие оператора if имеет значение true и один — если false.

Математически цикломатическая сложность структурированной программы определяется с помощью ориентированного графа, узлами которого являются блоки программы, соединенные рёбрами, если управление может переходить с одного блока на другой, nогда сложность определяется как:

***M = E − N + 2P***,

где: M - цикломатическая сложность, E - количество рёбер в графе, N - количество узлов в графе, P - количество компонент связности.

 В другой формулировке используется граф, в котором каждая точка выхода соединена с точкой входа. В этом случае граф является сильносвязным, и цикломатическая сложность программы равна цикломатическому числу этого графа, которое определяется как

***M = E − N + P*** 

 Это определение может рассматриваться как вычисление числа  линейно независимых циклов, которые существуют в графе, то есть тех циклов, которые не содержат в себе других циклов. Так как каждая точка выхода соединена с точкой входа, то существует по крайней мере один цикл для каждой точки выхода. Для простой программы, или подпрограммы, или метода  P  всегда равно 1.

 # 2. Рекомендуемый порог цикломатической сложности кода

 Чтобы иметь хорошую тестируемость, McCabe рекомендует, чтобы ни один программный модуль не превышал цикломатической сложности 10.

